---
title: Roadmap 2021 (2020-12-08)
sort: -202012080
contributors:
    - sokra
---

webpack 5 正式发布已有两月之久。由于赞助方面出了些小状况，我们不能再像之前那样花费很多时间在 webpack 上面了。我（@skra）个人休息了一段时间，并在这期间做了一些兼职项目。极具讽刺的是，当我在使用 webpack 5 及其所有前沿特性（asset modules，支持 worker，持久化缓存）时，我又发现了 webpack 5 中的一些 bug，而这些 bug 是大家将自己项目升级至 webpack 5 时可能会遇到的，因此，大量时间被用于修复这些 bug。以下是关于这些 bug 的小结：

## 从发布至今有哪些变化？ {#what-happened-so-far}

webpack 中又暴露了一些东西，其中包括类型及运行时相关的内容。同时，我们对一些处理性能低效的代码进行了改进。没有分号的代码曾在某些情况下生成一些无效/错误的代码，这一点也得到了修复。无副作用（side-effect-free）的代码 + 串连模块（concatenated modules）+ 重导出的组合时，会出现意料之外的情况，这一点也已修复（至少是已知的）。

但是用户报告的 bug 可能也会在 webpack 内部产生全新的特性。如果你对 webpack 内部的特性不感兴趣或者认为它太复杂，可以直接跳过此部分，进入下一章节。

要复现上述 bug，需了解：

- 从 webpack 5 开始，针对 `production` 模式进行了优化，此优化将对每个运行时（通常与入口相同）使用 exports 分析（Tree Shaking），这意味着 webpack 可以单独优化每个运行时（或入口）。
- 自定义的 `optimization.splitChunks` 配置允许将模块强行合并成一个 chunk。这可以通过传递 `name` 选项来实现。例如 `{ test: /node_modules/, name: "vendors" }`，会将 `node_modules` 中的模块合并到一个 chunk 中。虽然通常情况下并不推荐如此做，但这是可以的，并且在某些情况下可能是合理的。事物都有两面性，做好取舍即可。选择将所有的 verndor 合并到一个 chunk 中，可以很好的缓存这个 chunk，这将有利于在重复访问时或多个入口访问时。
- 当未使用导出的无副作用模块时，整个模块会从模块图中省略，`import` 语句根本不会产生运行时代码。

当两个入口的模块被合并到一个 chunk 中，并且它们又引用了一个不在共享 chunk 中的无副作用模块时，就会出现问题，因为只有入口使用了无副作用的导出。共享 chunk 中的模块被两个入口同时使用，因此，chunk 中需要引入任何一个入口中使用的导出。
这意味着，它会在上述情况下，生成引用无副作用模块的代码，而在运行时，且另一个入口不可用的情况下，这就会导致运行时代码出现 `undefined is not a function` 或 `cannot read property 'call' of undefined` 的错误。

一个简单的修复方式是，在所有的入口中加入无副作用的模块，但是有时并不真正需要这个模块，这就会造成对 bundle 大小的浪费。
所以我们另辟蹊径，那就是开发一个全新的特性：`runtime-dependent code generation`，即依赖运行时的代码生成。
此特性会根据运行时的不同而产生表现不同的代码。

事实上，我们会将生成的代码封装在 `if` 块中，所以它们只会在一个运行时执行。
在这个示例中，会影响到引用无副作用模块的 `import` 语句。
只会对其中一个入口执行 import。
如此就会避免引入不必要的模块，也避免了执行不必要的代码，即使它是可用。
因此，即使你把所有代码合并成一个 chunk，也只执行真正使用的代码。

到此为止，对于这次 bug 修复的体验，希望不会让你感到无聊...

## Roadmap 2021 {#roadmap-2021}

So assuming we can sort out our sponsoring situation, the following is planned for 2021:

### Further stabilizing {#further-stabilizing}

Our top-priority stays stabilizing webpack 5.
So far the situation looks pretty good.
Most critical bugs reported in the last time, affect some edge cases.
So I guess webpack 5 should work for the general cases.
But handling edge cases is (and should stay) one of webpack strength, so we want to continue to work hard fixing these.
We think that many many webpack users need custom things for their build and that's something webpack offers via configurability and its rich plugin system.

### EcmaScript Modules {#ecmascript-modules}

EcmaScript Modules (ESM) are slowly gaining wide-spread adoption.
On authoring side they are basically already the go-to standard to write code.
On browser support it also looks pretty ok (except for IE11 and a few older mobile browsers).
Browsers are still a bit lacking in supporting ESM for WebWorkers.

One can also generate bundles that run in a `type=module` script tag, but that has few benefits currently.

There are multiple areas in webpack where ESM support can be improved:

#### ESM as chunk loading mechanism {#esm-as-chunk-loading-mechanism}

When targeting the web webpack loads chunks via `script` tags.
When targeting node.js webpack loads chunks via `require` or `fs` + `vm`.
When targeting WebWorkers webpack loads chunk via `importScripts`.

In a not-so-far future, all these environments support ESM and more importantly the dynamic `import()` function.
So a chunk loading mechanism based on `import()` can unify all these environments, while even needing less runtime code.

#### Self-executed chunks {#self-executed-chunks}

Currently on-demand-loaded chunks in webpack are always containers for module and never execute module code directly.
When writing `import("./module")` in modules, this will compile to something like `__webpack_load_chunk__("chunk-containing-module.js").then(() => __webpack_require__("./module"))`.
There are many cases where this can't be changed (e.g. when loading multiple chunks or loading CSS too), but there are some cases where webpack could generate a chunk that directly executes the contained module.
This could lead to less generated code and would avoid the function wrapping in the chunk.

Currently I'm not yet sure if this is worth it, but it's at least worth looking into that.

#### ESM exports {#esm-exports}

Currently it's not possible to generate ESM exports for a bundle via `output.library.type: "module"`.
This can be useful when integrating webpack bundles into ESM loading environments or inline scripts.

T> For webpack 4 there is actually a plugin, but native support would be preferable.

#### ESM externals (import) {#esm-externals-import}

Webpack allows to define `externals` which are modules that are not bundled but exist at runtime.
There are many types of externals ranging from globals over CommonJs/AMD/System to loading from classic script tag.
Even `import()` (`type: "import"`) can be used to load an external, but `import` (`type: "module"`) can't be used yet.

Interestingly even while `type: "module"` isn't supported yet, webpack already uses it as default when writing e.g. `import x from "https://example.com/module.js"`.
The default has been choosing to seamlessly add support for ESM externals without introducing a breaking change.

Absolute URLs in `import`s can make sense e.g. when using external services that offer their API as ESM: `import { event } from "https://analytics.company.com/api/v1.js"` (`import("https://analytics.company.com/api/v1.js")` might make more sense to gracefully handle errors when depending on this external service, but errors could also be caught higher in module graph).

As usual the `externals` configuration allows to map any module name to externals:

``` js
export default {
  externalsType: 'module',
  externals: {
    analytics: 'https://analytics.company.com/api/v1.js',
    svelte: 'https://jspm.dev/svelte@3',
    react: 'https://cdn.skypack.dev/preact@10',
    'react-dom': 'https://esm.sh/[react,react-dom]/react-dom'
  }
};
```

W> Using multiple different ESM CDNs will not work. This is only an example.

#### ESM library {#esm-library}

When ESM exports and import are supported people might think bundling a library makes sense, and that's probably true in some cases, but in many cases natively bundling will result in worse results.
The biggest problem is the `"sideEffects": false` flag. It affects modules on per file base to skip whole modules. When concatenating multiple side-effect-free modules it's no longer possible to skip the individual modules, which leads to worse optimization when not all exports of the library are used.

When the output should be a library that will be processed by a bundler later, this needs to be considered.

I could think of a special mode, which does not apply chunking and instead, emit the raw (processed) modules connected via ESM imports and exports (or also CommonJS `require`).
So this basically means loaders, module graph, and asset optimizations run, but no chunk graph is created and each module in the module graph is emitted as a separate file.

#### Strict mode warnings {#strict-mode-warnings}

When generating an ESM bundle, all contained code will be forced to strict mode.
For many modules, this isn't an issue, but there are a few older packages that might have trouble with the different semantic.
We want to show warnings for these cases.

### More first-class citizen {#more-first-class-citizen}

webpack 4 and 5 did a lot of work to support non-JS module types, and webpack 5 already supports some module types by default: JS (ESM/CJS/AMD), JSON, WebAssembly, Asset.
Since webpack 5 one of our long term goals is to become a web-app optimizer, with the goal of supporting everything the browser supports.
So technically a vanilla web app should work out-of-the-box with webpack, but being optimized on the go.

The initial webpack 5 release already did some major steps in this direction: `new Worker` is supported natively. `new URL(...)` is supported natively (assets).

WebAssembly and JSON is already supported, even while the proposals are not finished yet.

But two resource types are still missing for the complete story: HTML and CSS.

#### CSS as modules {#css-as-modules}

Currently webpack supports CSS via `css-loader`, `style-loader` or `mini-css-extract-plugin`.
This is working pretty well, but I think we can do more by supporting CSS as a native module type in webpack.

A major benefit would be the developer experience: The `mini-css-extract-plugin` configuration is not the easiest and getting rid of it would simplify a lot for the developer.
Of course, that doesn't mean you can add additional customization on top of that.
I see many developers not using raw CSS, but using preprocessors on top of that (with native CSS support this would look like that: `{ test: /\.sass$/, type: "stylesheet", use: "sass-loader" }`).

As of [State of CSS 2020](https://2020.stateofcss.com/en-US/technologies/css-in-js/) CSS Modules is a popular way of writing modular CSS and it being a native module type in webpack allows to benefit from module graph optimization like Tree Shaking (Used Exports Optimization and Side-Effects optimization). When using CSS Modules this means the resulting CSS will only contain CSS rules that are referenced from the application (as one is used to from JS Tree Shaking).

There are some potential CSS Modules specific optimizations which are possible with the global knowledge of the application webpack has: CSS rules can be split into smaller rules to avoid repeating common properties. This can result in a much smaller payload as the output CSS contains fewer repeated properties (Atomic CSS).

But there is a big "BUT" here: There is work towards a different "CSS Modules" proposal in the WebComponents community, which is planned to become natively supported by browsers.
At least that's the goal of the proposal.
Sadly this proposal is different from what's currently used in the Frontend ecosystem but uses similar syntax.
Usually, webpack would align with proposals, so that's something to consider here.
We have to check whether it's possible to avoid potential conflicts.

#### HTML as entrypoint {#html-as-entrypoint}

Following Parcels example, we also want to support HTML natively as entrypoints.
Supporting that would be inline with the goal as web app optimizer, as web apps unusally start with a HTML.
It is also a huge developer experience improvement for beginners as many things can be inferred from the HTML.

Being in control of the generated HTML does also allow to optimize more aggressively by default.
Currently, we prevent renaming or splitting initial chunks by default, as this requires additional infrastructure for the HTML generation.

HTML entrypoints also benefit from CSS as modules and Asset modules, as these resources can be referenced from HTML too (e.g. `<link rel=stylesheet />`, `<img src="..." />`, `<link rel=icon />`).

#### HTML modules {#html-modules}

There is also a proposal about native support of importing HTML in browsers, that's something we will follow, especially as there is a huge overlap with HTML entrypoints.

### SourceMap performance {#sourcemap-performance}

Using (full) SourceMaps with webpack is currently quite expensive with webpack, as performance for SourceMap processing isn't the best.
This is something we want to look into for webpack, but also for terser, which is used by webpack as minimizer by default.

### `exports`/`imports` package.json field {#exports-imports-package-json-field}

Node.js 14 has added support for the `exports` field in package.json to allow to define entrypoints of a package.
Webpack 5 followed this, and even added additional conditions like `production/development`.

Shortly after that Node.js made further additionals to that, e.g. they also added an `imports` field for private imports.

That's something we also want to add.

### Improve CommonJS analysis {#improve-commonjs-analysis}

While ESM is the future, there are still a lot of CommonJS packages in npm and in use.
Webpack 5 added analysis for CommonJS modules to allow Tree Shaking for most of these modules.

But we can do more. While many exporting patterns are supported, only a few importing patterns are supported.
We want to add support for more patterns to allow more optimizations for CommonJS modules too.

### Hot Module Replacement for Module Federation {#hot-module-replacement-for-module-federation}

Webpack 5 added a new feature called "Module Federation" which allows integrating multiple builds together at runtime.
Currently, Hot Module Replacement (HMR) supports only a single build at a time and updates can't bubble between builds.
We want to improve here and allow HMR updates to bubble between different builds, which would improve developing federation applications.

### Hinting system {#hinting-system}

Currently, webpack displays warnings and errors to the user.
During the build, there are quite a few cases where we could tell the user something, like potential footguns or optimization opportunities, but they don't fit into warnings or errors and we don't want to spam the output with all this information.
So we want to add another category: Hints.
We want to collect all hints during builds (plugins could also emit some), but only display a limited number of them in the output (by default only one).
This should lead to some kind of "Did you know" experience for the user.

### Multi-Threading {#multi-threading}

While Persistent Caching makes cached build "blazing" fast, initial builds without Persistent Cache have still a bit of room for improvement.
Javascript execution in Node.js is single-threaded by default, but recent additions allow to use `worker_threads`, which is an API similar to WebWorkers.

This can be used distribute work across all CPUs. There has already been some preparations in webpack 5 for that: e.g. serializing of internal data structures is possible and the work queues support plugins. But some parts of that are still unclear and require experimentation.

This is in our voting list for a while, but not many have voted on that. Is this really something people need?

### WebAssembly {#webassembly}

Currently, WebAssembly is experimental and not enabled by default.
Once the proposal reaches Stage 4 we can enable it by default.

This might also lead to a wider adoption of WebAssembly in the ecosystem.
I think we might see more in this field in 2021.

## Disclaimer {#disclaimer}

This list is not set in stone.
The web ecosystem changes so fast that we probably end up implementing totally different things, that we might not even aware of at this time.
We do not even know how much time we can invest in webpack, considering our current sponsoring situation.
