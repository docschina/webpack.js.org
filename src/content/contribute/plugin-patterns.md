---
title: 插件模式
sort: 5
---

插件授予无限的机会在webpack构建系统中执行自定义。 这使您可以创建自定义资产类型，执行独特的构建修改，甚至可以在使用中间件时增强webpack运行时。 以下是在编写插件时变得有用的webpack的一些功能。

## 探索资源，块，模块和依赖关系

编译完成后，编译中的所有结构都可以遍历。

```javascript
function MyPlugin() {}

MyPlugin.prototype.apply = function(compiler) {
  compiler.plugin('emit', function(compilation, callback) {

    // Explore each chunk (build output):
    compilation.chunks.forEach(function(chunk) {
      // Explore each module within the chunk (built inputs):
      chunk.modules.forEach(function(module) {
        // Explore each source file path that was included into the module:
        module.fileDependencies.forEach(function(filepath) {
          // we've learned a lot about the source structure now...
        });
      });

      // Explore each asset filename generated by the chunk:
      chunk.files.forEach(function(filename) {
        // Get the asset source for each file generated by the chunk:
        var source = compilation.assets[filename].source();
      });
    });

    callback();
  });
};

module.exports = MyPlugin;
```

- `compilation.modules`：编译中的模块数组（内置输入）。 每个模块管理源库中的原始文件的构建。
- `module.fileDependencies`：包含在模块中的一系列源文件路径。 这包括源JavaScript文件本身（如：index.js）以及它所需的所有依赖资源文件（样式表，图像等）。 查看依赖关系对于查看哪些源文件属于某个模块很有用。
- `compilation.chunks`：汇编中的一组块（构建输出）。 每个块管理最终呈现资产的组成。
- `chunk.modules`：包含在块中的模块数组。 通过扩展，您可以查看每个模块的依赖关系，以查看输入到块中的原始源文件。
- `chunk.files`：由块生成的输出文件名数组。 您可以从`compilation.assets`表中访问这些资产来源。

### Monitoring the watch graph

While running webpack middleware, each compilation includes a `fileDependencies` array (what files are being watched) and a `fileTimestamps` hash that maps watched file paths to a timestamp. These are extremely useful for detecting what files have changed within the compilation:

```javascript
function MyPlugin() {
  this.startTime = Date.now();
  this.prevTimestamps = {};
}

MyPlugin.prototype.apply = function(compiler) {
  compiler.plugin('emit', function(compilation, callback) {

    var changedFiles = Object.keys(compilation.fileTimestamps).filter(function(watchfile) {
      return (this.prevTimestamps[watchfile] || this.startTime) < (compilation.fileTimestamps[watchfile] || Infinity);
    }.bind(this));

    this.prevTimestamps = compilation.fileTimestamps;
    callback();
  }.bind(this));
};

module.exports = MyPlugin;
```

You may also feed new file paths into the watch graph to receive compilation triggers when those files change. Simply push valid filepaths into the `compilation.fileDependencies` array to add them to the watch. Note: the `fileDependencies` array is rebuilt in each compilation, so your plugin must push its own watched dependencies into each compilation to keep them under watch.

## Changed chunks

Similar to the watch graph, it's fairly simple to monitor changed chunks (or modules, for that matter) within a compilation by tracking their hashes.

```javascript
function MyPlugin() {
  this.chunkVersions = {};
}

MyPlugin.prototype.apply = function(compiler) {
  compiler.plugin('emit', function(compilation, callback) {

    var changedChunks = compilation.chunks.filter(function(chunk) {
      var oldVersion = this.chunkVersions[chunk.name];
      this.chunkVersions[chunk.name] = chunk.hash;
      return chunk.hash !== oldVersion;
    }.bind(this));

    callback();
  }.bind(this));
};

module.exports = MyPlugin;
```
